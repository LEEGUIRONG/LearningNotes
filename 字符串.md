# 字符串

## 字符

### [520. 检测大写字母](https://leetcode-cn.com/problems/detect-capital/)

**题目描述：**

![image-20210720200202025](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210720200202025.png)

**题解：**

```python
class Solution:
    def detectCapitalUse(self, word: str) -> bool:
        # return word.islower() or word.isupper() or (word[0].isupper() and word[1:].islower())
        return word.upper() == word or word.lower() == word or word.title() == word

```

```python
class Solution:
  def detectCapitalUse(self, word: str) -> bool:
    return word.islower() or word.isupper() or word.istitle()
    #.islower()判断是否全小写
    #.isupper()判断是否全大写
    #.istitle()判断是否只有首字母大写
```

## 回文串的定义

### [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

**题目描述：**

![image-20210720200612503](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210720200612503.png)

**题解：**

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        all = []
        for i in s:
            if i.isalnum():
                all.append(i.lower())
        # b = list(reversed(all))
        return all == all[::-1]
```

```python
class Solution:
  def isPalindrome(self, s: str) -> bool:
    s=''.join(filter(str.isalnum,s)).lower()#filter 过滤字符串，str.isalnum检测
是否只由数字和字符串组成
    return s==s[::-1]
```

```python
class Solution:
    def isPalindrome(self, s: str) -> bool:

        left,right = 0 , len(s)-1
        while left < right:
            while left < right and not s[left].isalnum():
                left += 1
            while left < right and not s[right].isalnum():
                right -= 1
            if left < right:
                if s[left].upper() != s[right].upper():
                    return False
                left += 1
                right -= 1
        return True

```

## 公共前缀

### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

**题目描述：**

![image-20210720202119523](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210720202119523.png)

**题解：**

```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ("")
        str1 = min(strs)
        str2 = max(strs)
        for i in range(len(str1)):
            if str1[i] != str2[i]: #如果在s2中遇到了一个不同的
                return str1[:i] #那么s1中，位置i前面的就是公共字符串
        return str1
        
```

## 单词

### [434. 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)

**题目描述：**

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

**题解：**

```python
class Solution:
    def countSegments(self, s: str) -> int:
        count = 0 
        for i in range(len(s)):
            if (i==0 or s[i]==' ') and s[i-1] != ' ':
                count += 1
        return count
```

```python
class Solution:
    def countSegments(self, s: str) -> int:
        if len(s) == 0:
            return (0)
        else:
            return(len(s.split())) # 默认按照空格，制表符等进行切分
```

### [58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)

**题目描述：**

![image-20210720211426786](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210720211426786.png)

**题解：**

```python
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        s=s.strip(' ')#去掉头尾空格
        words = s.split(' ')
        if len(words) == 0:
            return 0
        return (len(words[-1]))
```

## 字符串的反转

### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

**题目描述：**

![image-20210720211745898](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210720211745898.png)

**题解：**

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left = 0 
        right = len(s) - 1
        while left < right:
            s[left],s[right] = s[right],s[left]
            left += 1
            right -= 1                         
        return s
```

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        for i in range(len(s)//2):
            s[i],s[-i-1] = s[-i-1],s[i]
        return s
```

### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

**题目描述：**

![image-20210720213311112](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210720213311112.png)

**题解：**

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        
        a = list(s)
        for i in range(0,len(s)-1,2*k): #每个2k个字符，取一次，然后对这个字符到这个字符+k的这个范围的字符进行反转，直接逆序
            a[i:i+k] = a[i:i+k][::-1]
        return "".join(a)
```

```python
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        left,mid,right = 0,k,2*k #初始化左中右指针，分别指向需要翻转的开始位置，结束位置，和下一个需要翻转的位置
        res = '' #初始化结果字符串
        while len(res) < len(s): # 只要长度不一样，说明没有反转完，继续执行
            res += s[left:mid][::-1] + s[mid:right] # 把当前单元的结果添加到结果字符串
            left,mid,right = left+2*k, mid + 2*k , right+2*k 
        return res
```

### [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

难度：简单

**题目描述：**

![image-20210720214437628](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210720214437628.png)

**题解：**

```python 
class Solution:
    def reverseWords(self, s: str) -> str:
        words = s.split()
        res = ''
        for i in words:
            res += i[::-1] + ' '        
        return res[0:len(res)-1] #要把最后多加的空格去掉
```

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join(i[::-1] for i in s.split()) #注意''中间要有个空格，表示字符串里面的字符要进行分割
```

## 字符的统计

### [387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

难度：简单

**题目描述：**

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**题解：**

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        count = collections.Counter(s)
        for index,item in enumerate(s):
            if count[item] == 1:
                return index
        return -1
```

想不起来collections.Counter()时：

```python
class Solution:
    def firstUniqChar(self, s: str) -> int:
        count = dict()
        for i in s: # 建立一个字典，存储的是字符和其重复的次数
            count[i] = count.get(i,0) +1
        # count = collections.Counter(s)
        for index,item in enumerate(s):
            if count[item] == 1:
                return index
        return -1
```

### [389. 找不同](https://leetcode-cn.com/problems/find-the-difference/)

难度：简单

**题目描述：**

给定两个字符串 ***s*** 和 ***t***，它们只包含小写字母。

字符串 ***t\*** 由字符串 ***s\*** 随机重排，然后在随机位置添加一个字母。

请找出在 ***t*** 中被添加的字母。

**题解：**

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        a = Counter(s)
        b = Counter(t)
        return list(b-a)[0]
```

如果将两个字符串拼接成一个字符串，则问题转换成求字符串中出现奇数次的字符。

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        ans = 0
        for i in s:  # ord()函数是chr()函数（对于8位的ASCII字符串）或unichr（）函数（对于unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的ASCII数值
            ans ^= ord(i)
        for j in t:
            ans ^= ord(j)
        return chr(ans)
```

### [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

难度：简单

**题目描述：**

![image-20210722172814440](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210722172814440.png)

**题解：**

```python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        a = Counter(magazine)
        for i in ransomNote:
            a[i] -= 1
            if a[i] < 0:
                return False
        return True
```

### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

难度：简单

**题目描述：**

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

**题解：**

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s)==Counter(t)
```

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return sorted(s) == sorted(t)
```

counter会比sorted快。

这道题不能用异或，因为很有可能出现虽然两个字符串中字母相同，但是在两个字符串中都是2 4 6 这样的倍数的情况，就会无法判断。



### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

难度：中等

**题目描述：**

![image-20210722180444506](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210722180444506.png)

**题解：**

```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]: 
        count = {}
        for i in strs:
            s = ''.join(sorted(i)) #对列表中的字符串做排序处理，这样相同元素字符串就一样了。
            # 遍历把排序字符当键，原元素当值加入列表。 这样就达到了去除重复项的目的
            if s not in count: 
                count[s] = [i]
            else:
                count[s].append(i)
        return [v for v in count.values()]
```

### [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

难度：中等

**题目描述：**

给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

![image-20210722182750391](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210722182750391.png)

**题解：**

```python
class Solution:
    def frequencySort(self, s: str) -> str:
        res = ''
        for i,t in Counter(s).most_common():
            res += i*t
        return res
```

### [423. 从英文中重建数字](https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/)

难度：中等

**题目描述：**

给定一个**非空**字符串，其中包含字母顺序打乱的英文单词表示的数字`0-9`。按升序输出原始的数字。

**题解：**

第一步：先找到能区别某个专属单词的字母，比如z只有单词zero有，w只有单词two等；
第二步：剩下不含有区分字母的单词，利用前面找出来的单词计算出来，比如four可以通过特有的u找出来，0~9中只有four和five中包含字母f，所以five的个数即为f的个数-four的个数，即cnt['f']-n4

```python
class Solution:
    def originalDigits(self, s: str) -> str:
        # zero one two three four five six seven eight nine 
        # 找到每个专属于某个单词的字母，剩下的单词个数由已经算出来的字母推导出
        count = Counter(s)
        n0 = count['z']
        n2 = count['w']
        n4 = count['u']
        n6 = count['x']
        n8 = count['g']

        n5 = count['f'] - n4
        n1 = count['o'] - n0 - n2 -n4
        n3 = count['t']-n2-n8
        n9 = count['i']-n6-n5-n8
        n7 = count['s']-n6
        # 存储每个单词的个数
        res = (n0,n1,n2,n3,n4,n5,n6,n7,n8,n9)
        return ''.join(str(index)*item for index,item in enumerate(res))


```

### [657. 机器人能否返回原点](https://leetcode-cn.com/problems/robot-return-to-origin/)

难度：简单

**题目描述：**

在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。

移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。

注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

![image-20210723100124287](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210723100124287.png)

**题解：**

```python
class Solution:
    def judgeCircle(self, moves: str) -> bool:
        count = Counter(moves)
        return count['U'] == count['D'] and count['L'] == count['R']
```

### [551. 学生出勤记录 I](https://leetcode-cn.com/problems/student-attendance-record-i/)

难度：简单

**题目描述：**

![image-20210723100928402](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210723100928402.png)

**题解：**

```python
class Solution:
    def checkRecord(self, s: str) -> bool:
        counta = 0
        countl = 0
        for i in range(len(s)):
            if s[i] == 'A':
                counta += 1
                if counta > 1:
                    return False
            if s[i] == 'L':
                countl += 1
                if countl > 2:
                    return False
            else:
                countl = 0
        return True

```

```python 
class Solution:
    def checkRecord(self, s: str) -> bool:
        return s.count('A') < 2 and 'LLL' not in s
        # return Counter(s)['A']<2 and 'LLL' not in s  # 这样写也是可以的
        # 注意count 和Counter 的用法区别
```

### [696. 计数二进制子串](https://leetcode-cn.com/problems/count-binary-substrings/)

难度：简单

**题目描述：**

给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。

重复出现的子串要计算它们出现的次数。

![image-20210723105050973](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210723105050973.png)

**题解：**

```python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        count = []
        tmp = 1
        for i in range(1,len(s)):  
            if s[i] == s[i-1]:
                tmp += 1
            else:
                count.append(tmp)
                tmp = 1
        count.append(tmp) # 记得把最后一次加进去，因为前面的遍历顺序其实是算的跳跃点
        res = 0
        for i in range(1,len(count)):
            res += min (count[i],count[i-1]) # 然后每次比较相邻的最小的
        return res
```

### [467. 环绕字符串中唯一的子字符串](https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/)

难度：中等

**题目描述：**

![image-20210723130254271](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210723130254271.png)

**题解：**

```python
class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        #其实就是字母表的顺序，所以用ord换成asciii码就可以判断是否符合顺序
        # 注意因为字符串是循环，所以z可能出现在a前面，所以判断的时候不仅是差为1，还有25

        # 每次记录以第j个元素结束的字串，以元素j结尾的排序的个数就是j是第几个连续的字符
        # abc 以a结尾1个，b 2个 c 3个
        if not p:
            return  0
        # 记录每个以字母为结尾的最长子串即可
        dic = collections.defaultdict(int)
        dic[p[0]] = 1
        t = 1
        res = 0
        for i in range(1,len(p)):
            # 注意za组合也是连续的
            if ord(p[i]) - ord(p[i-1]) == 1 or ord(p[i-1]) - ord(p[i]) == 25:
                # 如果连续，累计连续字串长度 t+1
                t += 1
            # 不连续，t复原为1，开始新的判断
            else:
                t = 1
            # 每次以j结束的子串数目都要更新
            # 用了取最大值防止重复出现的元素出现重复计数
            dic[p[i]] = max(dic[p[i]],t)
        for key in dic:
            res += dic[key]
        return res


```

### [535. TinyURL 的加密与解密](https://leetcode-cn.com/problems/encode-and-decode-tinyurl/)

难度：中等

**题目描述：**

![image-20210723193232348](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210723193232348.png)

**题解：**

```python
import random
import string
class Codec:
    def __init__(self):
        self.url_dics={}

    def getkey(self):
        return ''.join(random.sample(string.ascii_letters+string.digits,6))

    def encode(self, longUrl: str) -> str:
        """Encodes a URL to a shortened URL.
        """
        key = self.getkey()
        # while key in self.url_dics:
            # key = self.getkey()
        self.url_dics[key] = longUrl
        return 'http://tinyur1.com/' + key 
        

    def decode(self, shortUrl: str) -> str:
        """Decodes a shortened URL to its original URL.
        """
        return self.url_dics[shortUrl[19:]]
        # return self.url_dics[shortUrl.replace('http://tinyurl.com/','')]

# Your Codec object will be instantiated and called as such:
# codec = Codec()
# codec.decode(codec.encode(url))
```

## 数字与字符串间转换

### [299. 猜数字游戏](https://leetcode-cn.com/problems/bulls-and-cows/)

难度：中等

**题目描述：**

你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：

你写出一个秘密数字，并请朋友猜这个数字是多少。
朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对（称为“Cows”, 奶牛）。
朋友根据提示继续猜，直到猜出秘密数字。
请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。

xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。
yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。
请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。

![image-20210728214237800](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210728214237800.png)

**题解：**

```python
class Solution:
    def getHint(self, secret: str, guess: str) -> str:            
        bulls = 0  #记录公牛
        cows = 0  # 记录奶牛数
        for i in range(len(secret)):
            if secret[i] == guess[i]:
                bulls += 1
        base = set(guess)  # 以免重复计数
        for j in base:
            if j in secret:
                    cows += min(guess.count(j),secret.count(j))
        cows = cows - bulls

        return str(bulls)+'A'+str(cows)+'B'
```

