## 用栈访问最后若干元素

### [682. 棒球比赛](https://leetcode-cn.com/problems/baseball-game/)

难度：简单

**题目描述：**

你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。

比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：

​		1.整数 x - 表示本回合新获得分数 x
​		2."+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。
​		3."D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。
​		4."C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。
请你返回记录中所有得分的总和。

![image-20210728195707249](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210728195707249.png)

**题解：**

```python
class Solution:
    def calPoints(self, ops: List[str]) -> int:
        res = []
        for i in ops:
            if i == '+':
                tmp1 = res[-1]
                tmp2 = res[-2]
                res.append(tmp1+tmp2)
            elif i == 'D':
                tmp = res[-1]
                res.append(tmp*2)
            elif i == 'C':
                res.pop()
            else:
                res.append(int(i))
        return sum(res)


```

### [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)

难度：中等

**题目描述：**

![image-20210728200935803](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210728200935803.png)

**题解：**

```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        res = []
        paths = path.split('/') # 切分可以帮助去除多余的斜杠，因为切分之后得到的paths是没有斜杠的
        for i in paths:
            if i == '.' or i == '':  # 切分之后是有空位置的，也要进行判断
                continue
            elif i == '..':
                if res:
                    res.pop()
            else:
                res.append(i)
        return '/' +'/'.join(res)
        
```

### [388. 文件的最长绝对路径](https://leetcode-cn.com/problems/longest-absolute-file-path/)

难度：中等

**题目描述：**

![image-20210728203126558](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210728203126558.png)

**题解：**

```python
class Solution:
    def lengthLongestPath(self, input: str) -> int:
        # 利用\n统计单词，利用\t判断单词在第几层
        # 因为后面的文件只与前面最深的文件有关，只需记录在每个缩进个数的长度即可
        # 处理文件，需要判断更新max_depth。处理文件夹，需要更新depth_dict。 每次遍历到文件夹的时候都要更新depth_dict而不是取max，因为我们后期可能回到更小的depth去。
        if '.' not in input:
            return 0
        depth_dict = {0:0}  # key = depth, 即每行tab (\t) 的个数,value：当前depth文件夹的字符数量
        max_depth = 0
        for i in input.split('\n'):
            name = i.lstrip('\t')
            depth = len(i) - len(name) # depth由tab (\t) 的个数计算得来
            if '.' in name:  # 当前正在处理一个文件，需要判断更新max_depth
                max_depth = max(max_depth,len(name)+depth_dict[depth])
            else:
            # 当前正在处理一个文件夹，需要更新depth_dict
             # 为什么这里不取max呢？因为我们后期可能回到更小的depth去。题目中指出aaaaaaaaaaa/sth.png 是要比a/aa/aaa/file1.txt更长的。所以每次遍历到一个文件夹的时候都要更新depth_dict
                depth_dict[depth+1] = len(name) + depth_dict[depth] + 1
        return max_depth

```

 

```python
class Solution:
    def lengthLongestPath(self, input: str) -> int:
        paths = input.split('\n') #按照n划分
        cur = '\t'
        path_num = []  # 存t的数量
        file_path = []
        for i in range(len(paths)):
            num = paths[i].count(cur)
            paths[i] = paths[i].replace(cur,'')
            path_num.append(num)
        for i in range(len(paths)):
            if '.' in paths[i]: # 找到文件名
                file = paths[i]
                p = path_num[i] #找到有几个t就是第几层
                while p > 0:
                    if path_num[i-1] == p-1:#找前面的是不是路径
                        file = paths[i-1] + '/' + file
                        p = p-1
                    i = i-1
                file_path.append(file)
        if not file_path:
            return 0 
        max = 0
        for i in range(len(file_path)): # 返回长度，只有长度大于0才返回长度，否则返回0
            if len(file_path[i])>max:
                max = len(file_path[i])
        return max
```

