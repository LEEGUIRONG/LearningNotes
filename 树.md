# 树-列表

![image-20210722201152022](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210722201152022.png)

# 树与递归

### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

难度：简单

**题目描述：**

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        # 首先是根节点和根节点之间的比较
        if not p and not q : return True
        if not p and q : return False
        if p and not q : return False
        if p.val != q.val : return False
        # 排除以上情况后就只剩下true
        # 对p和q的左右子树分别进行相同的比较，所以利用递归
        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
```

### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

难度-中等

**题目描述：**

![image-20210722202623910](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210722202623910.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def countNodes(self, root: TreeNode) -> int:
        #节点总数=左子树的节点数+右子树的节点数
        #左右子树的节点树的计算方法：把左子树和右子树的节点当作根节点，再次进行相同的操作
        if not root:
            return 0
        l = self.countNodes(root.left)
        r = self.countNodes(root.right)
        return l+r+1
```

### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

难度：简单

**题目描述：**

给定一个二叉树，检查它是否是镜像对称的。

 ![image-20210722203453202](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210722203453202.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True # 如果不是root，那么是对称的
        def leftandright(p,q):
            if not p and not q: return True # 如果左右节点不存在，那么是对称的
            if p and q and p.val==q.val: # 如果左右节点相等，那么就继续往下找，进行递归
                return leftandright(p.left,q.right) and leftandright(p.right,q.left)
            return False #其他情况都是false
        return leftandright(root.left,root.right) #根节点的左右子树进行操作

```

### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

难度：简单

**题目描述：**

翻转一棵二叉树。

![image-20210722204532500](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210722204532500.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None  #函数的终止条件是空的时候
        #它要做的事情就是同时对左右子树进行处理
        root.left,root.right = self.invertTree(root.right),self.invertTree(root.left)
        return root #最后还要返回的是原来的树，所以依然是树的根节点


```

### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

难度：中等

**题目描述：**

给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。

路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

![image-20210722210752171](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210722210752171.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        self.ans = 0
        def allsum(root):
            if not root:
                return [] # 递归终点
            possible = [root.val]
            if root.val == targetSum:
                self.ans += 1
            left = allsum(root.left)
            right = allsum(root.right)
            for i in left:
                tmp = root.val+i # 根+左可能值
                possible.append(tmp)
                if tmp == targetSum:
                    self.ans += 1 #一直记录的都是前缀和等于sum的次数
            for i in right:
                tmp = root.val + i # 根+右可能值
                possible.append(tmp) # 选择了走左边，那右边就不能加了，右边同理，只能加一条
                if tmp == targetSum:
                    self.ans += 1
            return possible

        allsum(root)
        return self.ans
        
```

### [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)

难度：简单

**题目描述：**

![image-20210723203921239](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210723203921239.png)

**题解：**

`left+right+root.val` 为什么返回的是该节点左孩子和右孩子及其该节点值的和，因为tilt是该节点左子树节点值总和减去右子树节点值总和。这个 `left+right+root.val` 是这个子树的各个节点的总和，给该子树root的父节点计算tilt作准备。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findTilt(self, root: TreeNode) -> int:
        self.res = 0
        def dfs(root):
            # 这个函数是要返回节点之和，并且记录该节点的坡度
            if not root:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.res += abs(left-right)
            return left+right+root.val
        dfs(root)
        return self.res
        
```

### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

难度：简单

**题目描述：**

![image-20210723204601723](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210723204601723.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        # 这个函数的作用是返回新的root1
        if not root1:
            return root2
        if not root2:
            return root1
        root1.val = root1.val + root2.val #新root1的节点值等于两个root的节点值之和
        root1.left = self.mergeTrees(root1.left,root2.left) #新root1的左子树等于两个左子树之和
        root1.right = self.mergeTrees(root1.right,root2.right) # 新root1的右子树等于两个右子树之和
        return root1 # 返回的是新root1

```

### [508. 出现次数最多的子树元素和](https://leetcode-cn.com/problems/most-frequent-subtree-sum/)

难度：中等

**题目描述：**

![image-20210723211635709](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210723211635709.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findFrequentTreeSum(self, root: TreeNode) -> List[int]:
        tmp = []
        # 定义函数，作用是返回根节点和左右节点的和，并且把和存在tmp里面
        def _sum(root):
            if not root:
                return 0
            left = _sum(root.left)
            right = _sum(root.right)
            tmp.append(root.val + left + right)
            return root.val + left + right
        _sum(root)

        dic = {} # 对字典进行排序
        for i in tmp:
            dic[i] = dic.get(i,0) + 1
        d = sorted(dic.items(),key = lambda item:item[1])

        ans = []
        for k,v in dic.items():
            if v == d[-1][1]:
                ans.append(k)
        return ans
```

### [572. 另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

难度：简单

**题目描述：**

![image-20210724193401884](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210724193401884.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubtree(self, root: TreeNode, subRoot: TreeNode) -> bool:
        if not root and not subRoot:
            return True
        if not root or not subRoot:
            return False
        return self.isSameTree(root,subRoot) or self.isSubtree(root.left,subRoot) or self.isSubtree(root.right,subRoot)

    def isSameTree(self,root,subRoot):
        if not root and not subRoot:
            return True
        if not root or not subRoot:
            return False
        return root.val == subRoot.val and self.isSameTree(root.left,subRoot.left) and self.isSameTree(root.right,subRoot.right)
    
```

### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

难度：简单

**题目描述：**

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

![image-20210724195624207](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210724195624207.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.ans = 1 # 先定义最短的，至少为1
        def depth(root): # 找最深的
            if not root: 
                return 0
            L = depth(root.left) # 左边树的节点数
            R = depth(root.right) # 右边树的节点数
            self.ans = max(self.ans, L + R +1) # 更新为节点数和左右节点与根节点的和
            return max(L,R) + 1
        depth(root)
        return self.ans - 1 
```

### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

难度：中等

**题目描述：**

给定一个不含重复元素的整数数组 nums 。一个以此数组直接递归构建的 最大二叉树 定义如下：

二叉树的根是数组 nums 中的最大元素。
左子树是通过数组中 最大值左边部分 递归构造出的最大二叉树。
右子树是通过数组中 最大值右边部分 递归构造出的最大二叉树。
返回有给定数组 nums 构建的 最大二叉树 。

![image-20210724202321371](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210724202321371.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
        if not nums:
            return None
        maxv = max(nums) 
        maxvi = nums.index(maxv) # 找到数组中最大的树的下标
        root = TreeNode(maxv) # 构建树
        root.left = self.constructMaximumBinaryTree(nums[:maxvi]) # 对最大的数左边的数进行如上操作
        root.right = self.constructMaximumBinaryTree(nums[maxvi+1:]) # 对最大的数右边的树进行如上操作，注意范围
        return root
```

### [687. 最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/)

难度：中等

**题目描述：**

给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

**注意**：两个节点之间的路径长度由它们之间的边数表示。

![image-20210724203330741](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210724203330741.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.res = 0

    def longestUnivaluePath(self, root: TreeNode) -> int:
        def maxlen(node): # 记录点输入的过程
            if node == None:
                return 0
            left = maxlen(node.left) # 对左右子树都进行这样的操作
            right = maxlen(node.right)
            if node.left: # 如果节点有左子树，并且根节点的值等于左子树的值，则值加1，否则为0
                left = left + 1 if node.left.val == node.val else 0
            if node.right:
                right = right + 1 if node.right.val == node.val else 0
            self.res = max(self.res, left+right) # 当前的root.val是相同的
            return max(left,right) 
        maxlen(root)
        return self.res
                
```

### [87. 扰乱字符串](https://leetcode-cn.com/problems/scramble-string/)

难度：困难

**题目描述：**

![image-20210724210159519](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210724210159519.png)

![image-20210724210212404](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210724210212404.png)

**题解：**

在 Python 中，有一个实现记忆化递归的神器，就是 functool模块的 lru_cache装饰器，它可以把函数的输入和输出结果缓存住，在后续调用中如果遇到了相同的输入，直接从缓存里面读。顾名思义，它使用的是 LRU （最近最少使用）的缓存淘汰策略。

@functools.lru_cache(maxsize=None, typed=False)

- `maxsize` 为最多缓存次数，如果为 None，则无限制；
- `typed=True` 时，表示不同参数类型的调用将分别缓存。

```python
class Solution:
    @functools.lru_cache(None)
    def isScramble(self, s1: str, s2: str) -> bool:
        N = len(s1)
        if N == 0: return True
        if N ==1 : return s1==s2
        if sorted(s1) != sorted(s2):
            return False
        for i in range(1,N):
            if self.isScramble(s1[:i],s2[:i]) and self.isScramble(s1[i:],s2[i:]):
                return True
            if self.isScramble(s1[:i],s2[N-i:]) and self.isScramble(s1[i:],s2[:N-i]):
                return True
        return False


       
#         if len(s1) != len(s2):
#             return False
#         @functools.lru_cache(None)
#         def dfs(s1:str, s2:str) -> bool:
#             if s1 == s2: # 剪枝
#                 return True
#             if sorted(s1) != sorted(s2): # 如果元素的种类和个数不一样
#                 return False
#             n = len(s1)
#             for i in range(1,n):
#                 flag1 = dfs(s1[0:i],s2[0:i]) and dfs(s1[i:],s2[i:])
#                 flag2 = dfs(s1[0:i],s2[n-i:]) and dfs(s1[i:],s2[:n-i]) 
#                 if flag1 or flag2:
#                     return True
#             return False
#         return dfs(s1,s2)
```

# 二叉树的层序遍历

二叉树的层序遍历，就是图论中的广度优先搜索在二叉树中的应用，需要借助队列来实现）。

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。

而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。



### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

难度：中等

**题目描述：**

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 **题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        quene = [root]
        out_list = []
        while quene:
            length = len(quene)
            in_list = []
            for i in range(length):
                curnode = quene.pop(0) # 默认移除列表最后一个元素，这里需要移动队列最头上的那个
                in_list.append(curnode.val)
                if curnode.left:
                    quene.append(curnode.left)
                if curnode.right:
                    quene.append(curnode.right)
            out_list.append(in_list)
        return out_list
 # 需要借助一个辅助数据结构——队列来实现。队列先进先出，符合一层一层遍历的逻辑，栈先进后出适合模拟深度优先遍历也就是递归的逻辑。
# 而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

```

### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

难度：中等

**题目描述：**

给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = [root]
        out_list = []
        # return queue.pop(0)
        while queue:
            length = len(queue)
            in_list = []
            for i in range(length):
                curnode = queue.pop(0)
                in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
            out_list.append(in_list)
        out_list.reverse()
        return out_list

```

### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

难度：中等

**题目描述：**

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

![image-20210725163736090](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725163736090.png)

**题解：**

最开始被例子的图错误引导了，想着每次都加最右侧的点进去，后来发现如果某一层只有左子树没有右子树看到的就是左子树，想着把左子树和右子树进行判断，选择是否加入，但是仍然存在问题：最底层的节点，如果其父节点不是能被看到的，那最底层节点也不会被访问。所以直接层序遍历，返回每一层最右边的节点即可。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        
        queue = [root]
        out_list = []

        while queue:
            length = len(queue)
            in_list = []
            for i in range(length):
                curnode = queue.pop(0)
                in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
            out_list.append(in_list)
        res = []
        for i in out_list:
            res.append(i[-1])
        return res  #返回层序遍历每一层的最右边的元素构成的数组。
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        
        queue = [root]
        out_list = []

        while queue:
            length = len(queue)
            in_list = []           
            for i in range(length):
                curnode = queue.pop(0)
                in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
            out_list.append(in_list[-1])
        return out_list
```

###  [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

难度：简单

**题目描述：**

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

![image-20210725165112583](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725165112583.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def averageOfLevels(self, root: TreeNode) -> List[float]:
        if not root:
            return []
        # deque来自collections模块，不在力扣平台时，需要手动写入
        # 'from collections import deque' 导入
        # deque相比list的好处是，list的pop(0)是O(n)复杂度，deque的popleft()是O(1)复杂度
        queue = deque([root]) # 作用跟queue = [root]一样的
        out_list = []

        while queue:
            length = len(queue)
            in_list = []
            for i in range(length):
                curnode = queue.popleft()
                in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
            # out_list.append(mean(in_list))
            out_list.append(in_list)
        out_list = map(lambda x : sum(x) / len(x),out_list)
        return out_list
        # map() 会根据提供的函数对指定序列做映射。 
        # 第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。
        
# 如果要用list.mean（）的话，需要引入numpy的包，所以用mean（list）求平均
```

### [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

难度：简单

**题目描述：**

给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。

树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

 ![image-20210725170809347](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725170809347.png)

**题解：**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return []

        queue = deque([root])
        out_list = []

        while queue:
            in_list = []
            for i in range(len(queue)):
                curnode = queue.popleft()
                in_list.append(curnode.val)
                if curnode.children:
                    queue.extend(curnode.children) # 不能用append
            out_list.append(in_list)
        return out_list
# append() 方法用于在列表末尾添加新的对象。
# extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
```

### [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

难度：中等

**题目描述：**

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

![image-20210725171317066](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725171317066.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        
        queue = deque([root])
        out_list = []

        while queue:
            in_list = []
            for i in range(len(queue)):
                curnode = queue.popleft()
                in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
            out_list.append(max(in_list))
        return out_list
```

### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

难度：中等

**题目描述：**

![image-20210725172048130](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725172048130.png)

![image-20210725172113166](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725172113166.png)

**题解：**

本题依然是层序遍历，只不过在单层遍历的时候记录一下本层的头部节点，然后在遍历的时候让前一个节点指向本节点就可以了

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""
# 层序遍历法
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        queue = deque([root])
        while queue:
            n = len(queue)
            for i in range(n):
                curnode = queue.popleft()
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
                if i == n-1:
                    break
                curnode.next = queue[0]
        return root

# 链表解法
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        first = root
        while first:
            cur = first
            while cur:  # 遍历每一层的节点
                if cur.left: cur.left.next = cur.right  # 找左节点的next
                if cur.right and cur.next: cur.right.next = cur.next.left  # 找右节点的next
                cur = cur.next # cur同层移动到下一节点
            first = first.left  # 从本层扩展到下一层
        return root
```

### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

难度：中等

**题目描述：**

![image-20210725174207497](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725174207497.png)![image-20210725174213506](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725174213506.png)**题解：**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        queue = deque([root])
        while queue:
            n = len(queue)
            for i in range(n):
                curnode = queue.popleft()
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
                if i == n-1:
                    break
                curnode.next = queue[0]
        return root
    
# 用尾节点会更加高效
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        queue = deque([root])
        while queue: # 遍历每一层
            n = len(queue)
            tail = None # 每一层维护一个尾节点
            for i in range(n): #遍历当前层
                curnode = queue.popleft()
                if tail:
                    tail.next = curnode # 让尾节点指向当前节点
                tail = curnode # 让当前节点成为尾节点
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
        return root
```

### [690. 员工的重要性](https://leetcode-cn.com/problems/employee-importance/)

难度：简单

**题目描述**：

给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。

比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。

现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。

![image-20210725180319578](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725180319578.png)

**题解：**

深度优先搜索的做法非常直观。根据给定的员工编号找到员工，从该员工开始遍历，对于每个员工，将其重要性加到总和中，然后对该员工的每个直系下属继续遍历，直到所有下属遍历完毕，此时的总和即为给定的员工及其所有下属的重要性之和。

实现方面，由于给定的是员工编号，且每个员工的编号都不相同，因此可以使用哈希表存储每个员工编号和对应的员工，即可通过员工编号得到对应的员工。

```python
"""
# Definition for Employee.
class Employee:
    def __init__(self, id: int, importance: int, subordinates: List[int]):
        self.id = id
        self.importance = importance
        self.subordinates = subordinates
"""


class Solution:
    def getImportance(self, employees: List['Employee'], id: int) -> int:
        d = {e.id: e for e in employees}
        def f(i):
            e = d[i]
            return e.importance + sum(map(f,e.subordinates))  #对所有的子节点也调用这个函数
        return f(id)

```

### [559. N 叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/)

难度：简单

**题目描述：**

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

![image-20210725190618732](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725190618732.png)

**题解：**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0
        queue = deque([root])
        res = 0
        while queue:
            in_list = []
            n = len(queue)
            for i in range(n):
                curnode = queue.popleft()
                in_list.append(curnode.val)
                if curnode.children:
                    queue.extend(curnode.children)
            res += 1
        return res
```

递归解法：

1.如果忽略递归部分，这个函数maxDepth返回的就是一个仅有一个节点的树的深度，就是root本身。
2.因为我们要对树上的每个节点都做这个事情，所以每个节点都要调用一遍maxDepth。于是就有了for
每个子节点，做一遍函数。
3.还要想办法和外界联系起来，就是子节点返回的东西必须和这个函数的return所联系。因为返回的是
树的最大深度，那么子节点每次返回的数和原来的值（父节点做过的或者兄弟节点比较后的max值）进
行比较即可。

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if not root:
            return 0
        res = 0
        # 递归部分
        for node in root.children:
            res = max(self.maxDepth(node),res)
        return res+1
```

### [671. 二叉树中第二小的节点](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/)

难度：简单

**题目描述：**

给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。

更正式地说，root.val = min(root.left.val, root.right.val) 总成立。

给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。

 ![image-20210725191434106](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725191434106.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -> int:
        if not root:
            return -1
        
        queue = deque([root])
        res_list = []

        while queue:
            in_list = []
            n = len(queue)
            for i in range(n):
                curnode = queue.popleft()
                in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
            res_list.extend(in_list)
        res = list(set(res_list))
        res.sort()
        return res[1] if len(res) >1 else -1

```

### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

难度：中等

**题目描述：**

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

![image-20210725192809884](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725192809884.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        if not root:
            return None
        
        queue = deque([root])
        out_list = []
        while queue: # 遍历每一层  
            in_list = []
            n = len(queue)
            for i in range(n): # 遍历当前层
                curnode = queue.popleft()
                in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
            out_list.append(in_list)
        return out_list[-1][0]
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# 节约一点存储空间
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        if not root:
            return None      
        queue = deque([root])
        while queue: # 遍历每一层  
            n = len(queue) #每一次都拿出队列最前面的数（最先加入的数，也就是最左边的数）
            last = queue[0]
            for i in range(n): # 遍历当前层
                curnode = queue.popleft() #把该层节点的子节点加入队列
                # in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
        return last.val   #如果发现没有节点再被加进来的话，那么就返回当前值      

```

### [103. 二叉树的锯齿形层序遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

难度：中等

**题目描述：**

给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

![image-20210725193932221](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725193932221.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        queue = deque([root])
        out_list = []
        s = 0 # 记录层数，双数层从左至右，单数层从右至左
        while queue:
            in_list = []
            for i in range(len(queue)):
                curnode = queue.popleft()
                in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
            out_list.append(in_list if s % 2 == 0 else in_list[::-1])
            s += 1
        return out_list

```

### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/) ？

难度：简单

**题目描述：**

给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。![image-20210725195127388](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725195127388.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        path = [] # 保存遍历路径的节点
        res = [] # 保存最终路径集合
        def backtrace(root,path):
            if not root:
                return
            path.append(root.val)
            if not root.left and not root.right: # 遇到叶子结点就放入当前路径到res集合中
                res.append(path[:])
            ways = []
            if root.left:
                ways.append(root.left)
            if root.right:
                ways.append(root.right)
            for way in ways:
                backtrace(way,path)
                path.pop() # 回溯
        backtrace(root,path)
        return ["->".join(list(map(str,i))) for i in res]


```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        if not root:
            return []
        path = []
        res = []

        def dfs(root):
            if not root:
                return 
            path.append(str(root.val))
            if not root.left and not root.right:
                res.append("->".join(path))
            dfs(root.left)
            dfs(root.right)
            path.pop() ### 注意这里，不累加左子树的结果，也就是左子树遍历完了之后会弹出pop结果
        dfs(root)
        return res
```

### [623. 在二叉树中增加一行](https://leetcode-cn.com/problems/add-one-row-to-tree/)

难度：中等

**题目描述：**

给定一个二叉树，根节点为第1层，深度为 1。在其第 d 层追加一行值为 v 的节点。

添加规则：给定一个深度值 d （正整数），针对深度为 d-1 层的每一非空节点 N，为 N 创建两个值为 v 的左子树和右子树。

将 N 原先的左子树，连接为新节点 v 的左子树；将 N 原先的右子树，连接为新节点 v 的右子树。

如果 d 的值为 1，深度 d - 1 不存在，则创建一个新的根节点 v，原先的整棵树将作为 v 的左子树。

![image-20210725203725643](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725203725643.png)

**题解：**

对于一个大问题：
addOneRow(root, v, d)
可以看到，对于小问题(v=8, d=2)来说，和大问题(v=8, d=3)的区别仅在与深度d的变化以及问题个数增加了。
这样就可以很方便的写出递归公式:
addOneRow(root.left, v, d-1)
addOneRow(root.right, v, d-1)

下面思考递归的终止条件：

如果当前节点为空，就不需要处理这个节点
d == 1 的情况，按照题目的要求：创建一个新的根节点v，原先的整棵树将作为 v 的左子树。
d == 2 的情况，就是上面第二张图中拆分过的情况。
创建值为v的两个新结点，把新结点插到根节点的左右子树上
把根节点原来的左子树，接到左新结点的左子树上。
把根节点原来的右子树，接到右新结点的右子树上。
对于d >= 2 的情况，我们只需要不断拆分这个大问题，直到符合上述的递归终止条件即可。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def addOneRow(self, root: TreeNode, val: int, depth: int) -> TreeNode:
        if not root:
            return 
        if depth == 1:
            node = TreeNode(val)
            node.left = root
            return node
        if depth == 2:
            L = TreeNode(val) # 新的左节点
            R = TreeNode(val) # 新的右节点

            L.left = root.left # 新的左节点的左子树 是原来的左子树
            R.right = root.right # 新的右节点的右子树  是原来的右子树

            root.left = L # 新的左节点成为原来根节点的左子树
            root.right = R # 新的右节点成为原来根节点的右子树
            return root
        self.addOneRow(root.left,val,depth-1)
        self.addOneRow(root.right,val,depth-1)
        return root
```

### [653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

难度：简单

**题目描述：**

给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 `true`。![image-20210725211327052](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725211327052.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        # 根据二叉搜索树的特点，左边小右边大，先用中序遍历得到有序数组
        nums = []
        def inorder(root):
            if root:
                inorder(root.left)
                nums.append(root.val)
                inorder(root.right)
        # 再利用双指针，进行查找
        inorder(root)  # 调用函数，对给定二叉搜索树进行中序遍历
        l,r = 0,len(nums)-1
        while l < r:
            if nums[l] + nums[r] == k:
                return True
            if nums[l] + nums[r] > k:
                r -= 1
            else:
                l += 1
        return False
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

难度：简单

**题目描述：**

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

![image-20210725212637145](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725212637145.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        queue = deque([root])
        res = 0 
        while queue:
            in_list = []
            for i in range(len(queue)):
                curnode = queue.popleft()
                in_list.append(curnode.val)
                if curnode.left:
                    queue.append(curnode.left)
                if curnode.right:
                    queue.append(curnode.right)
            res += 1
        return res
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        left = self.maxDepth(root.left)
        right = self.maxDepth(root.right)
        return max(left,right)+1
```

### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

难度：简单

**题目描述：**

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明：**叶子节点是指没有子节点的节点。

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        left = self.minDepth(root.left)
        right = self.minDepth(root.right)
        if (left == 0 and right != 0 ) or (left != 0 and right == 0): # 这个判断很关键，如果只有左子树或者只有右子树的时候，最小深度其实并不是只有一层
            return max(left,right) + 1 
        else:
            return min(left,right) + 1
```

### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

难度：简单

**题目描述：**

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。

叶子节点 是指没有子节点的节点。

![image-20210725214024831](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210725214024831.png)

**题解：**

递归：

从根节点往下找，找到叶子节点。先假设跟节点到当前节点的路径和为 val，那么将问题转变一下，是否能够找到从当前节点到叶子节点的路径和为 `sum - val`，这符合递归的性质。

那么也就是说从根节点往下找到叶子节点，如果确定当前节点是叶子节点，那么判断 sum 是否等于当前节点的 val 值即可。如果不是叶子节点，那么将继续向下查找。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if not root:
            return False
        if not root.left and not root.right:
            return targetSum == root.val
        return self.hasPathSum(root.left, targetSum-root.val) or self.hasPathSum(root.right,targetSum-root.val)

        # if not root:
        #     return False
        
        # targetSum -= root.val
        # if targetSum ==0:
        #     if not root.left and not root.right:
        #         return True 
        # return self.hasPathSum(root.left,targetSum) or self.hasPathSum(root.right,targetSum)
```

广度优先遍历：在这里我们使用队列，存储节点以及根节点到某个节点的路径和。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: TreeNode, targetSum: int) -> bool:
        if not root:
            return False
         # 队列存储节点和路径和       
        queue = deque()
        queue.append((root,root.val)) # 注意这里要用append来添加，因为加的是两部分
        while queue:
            # 出队，开始搜索
            curnode,path = queue.popleft()
            # 如果叶子节点，路径和等于目标值时，直接返回 True
            if not curnode.left and not curnode.right and path==targetSum:
                return True
            if curnode.left:
                queue.append((curnode.left,path+curnode.left.val))
            if curnode.right:
                queue.append((curnode.right,path+curnode.right.val))
        return False
```

### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

难度：中等

**题目描述：**

给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。

![image-20210726162217843](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726162217843.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: TreeNode, targetSum: int) -> List[List[int]]:
        if not root:
            return []
        res = []
        queue = deque()
        queue.append((root,[],0)) #将要处理的节点、路径、路径和
        while queue:
            node,path,pathsum = queue.popleft() 
            if not node:# 如果是空节点，不处理
                continue
            if not node.left and not node.right: #如果是叶子节点
                if node.val + pathsum == targetSum: # 加上叶子节点后，路径和等于sum
                    res.append(path[:] + [node.val]) #保存路径
            queue.append((node.left,path+[node.val],pathsum+node.val)) # 处理左子树
            queue.append((node.right,path+[node.val],pathsum+node.val)) # 处理右子树
        return res
                
```

### [129. 求根节点到叶节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

难度：中等

**题目描述：**

给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

例如，从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。
计算从根节点到叶节点生成的 所有数字之和 。

叶节点 是指没有子节点的节点。

![image-20210726162329050](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726162329050.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
# 广度优先搜索
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        if not root:
            return None
        queue = deque()
        queue.append((root,root.val)) #存储节点和节点对应的数字
        total = 0
        while queue:
            curnode , cursum = queue.popleft()
            if not curnode.left and not curnode.right: #如果当前节点是叶子节点，则将该节点对应的数字加到数字之和
                total += cursum 
            # 如果当前节点不是叶子节点，则获得当前节点的非空子节点，并根据当前节点对应的数字和子节点的值计算子节点对应的数字，然后将子节点和子节点对应的数字分别加入两个队列。
            if curnode.left:
                queue.append((curnode.left, curnode.left.val + cursum * 10))
            if curnode.right:
                queue.append((curnode.right,curnode.right.val + cursum * 10))
        return total # 所有叶子节点对应的数字之和

```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
    #深度优先搜索
        # 从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。
        def dfs(root,prevtotal):
            if not root :
                return 0
            total = prevtotal * 10 + root.val
            if not root.left and not root.right:
                return total
            else:
                return dfs(root.left,total) + dfs(root.right,total)
        return dfs(root,0)
```

### [655. 输出二叉树](https://leetcode-cn.com/problems/print-binary-tree/)

难度：中等

**题目描述：**

在一个 m*n 的二维字符串数组中输出二叉树，并遵守以下规则：

1.行数 m 应当等于给定二叉树的高度。
2.列数 n 应当总是奇数。
3.根节点的值（以字符串格式给出）应当放在可放置的第一行正中间。根节点所在的行与列会将剩余空间划分为两部分（左下部分和右下部分）。你应该将左子树输出在左下部分，右子树输出在右下部分。左下和右下部分应当有相同的大小。即使一个子树为空而另一个非空，你不需要为空的子树输出任何东西，但仍需要为另一个子树留出足够的空间。然而，如果两个子树都为空则不需要为它们留出任何空间。
4.每个未使用的空间应包含一个空的字符串""。
5.使用相同的规则输出子树。

![image-20210726165322667](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726165322667.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def printTree(self, root: TreeNode) -> List[List[str]]:        
        d = self.depth(root)       
        c = [[''for i in range(2**d - 1)]for i in range(d)]
        def dfs(root,level = 0,l=0,r = 2**d-1):
            if not root:
                return 
            mid = (l+r)//2
            c[level][mid] = str(root.val)
            dfs(root.left,level+1,l,mid-1)
            dfs(root.right,level+1,mid+1,r)
        dfs(root)
        return c
    def depth(self,root):
        if not root:
            return 0
        l = self.depth(root.left)
        r = self.depth(root.right)
        return max(l,r)+1
```















# 二叉树的前序、中序、后序遍历

![image-20210718214741425](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210718214741425.png)

**前序、中序、后序中的前中后就是根节点在遍历中的顺序。**

## 树的前序遍历

### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

**题目描述**![image-20210718214840344](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210718214840344.png)



**解题思路1： 递归**

首先定义一棵二叉树，二叉树有根节点，有左子树，有右子树。可以确定的是根节点是一个int，但是左子树和右子树也许也有它们各自的子树。所以先写了一个TreeNode类，定义了这个类的三个属性，self.val,self.left,self.right来存这棵树的根节点，和左右子树。

然后开始前序遍历，前序遍历的意思是指：根节点→左节点→右节点。所以我们先写一个Solution来存我们前序遍历这个结果。其中先定义函数preorderTraversal，它的主要作用就是：return 前序遍历的结果。

那么前序遍历的结果具体如何，就看这个更小的函数preorder(root)，它的作用就是对树在进行前序遍历，传入的是这棵树，返回前序遍历的结果。这个函数具体的实现逻辑如下结果中注释。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:

        def preorder(root:TreeNode):#该函数的作用是：1、添加root的当前节点，2、对当前节点的左子树做一样的事，3、对当前节点的右子树做一样的事
            if not root:
                return []
            res.append(root.val) #1、添加root的当前节点
            preorder(root.left) #2、对当前节点的左子树做一样的事（递归调用preorder）
            preorder(root.right)#3、对当前节点的右子树做一样的事（递归调用preorder）
        res = list()
        preorder(root)
        return res
```

**解题思路2：迭代**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        res , stack = [],[] # 利用栈进行临时存储
        stack.append(root)
        while len(stack):
            curr = stack.pop() # 取出一个节点，表示开始访问以该节点为根的子树
            res.append(curr.val) # 首先访问该节点（先序），之后顺序入栈右子树，左子树
            if curr.right:
                stack.append(curr.right)
            if curr.left:
                stack.append(curr.left)
        return res
```

### [589. N 叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)

**题目描述：**![image-20210719114645365](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210719114645365.png)

**解题思路1：和二叉树一样，对所有的子树遍历一遍递归。**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        def pre_order(root): # 这个函数的作用是：1、添加当前根节点 2、对根节点的所有孩子节点都做一样的事（递归调用
            if not root:
                return
            res.append(root.val)
            for u in root.children:
                pre_order(u)
        res = []
        pre_order(root)
        return res 
```

**解题思路2：迭代，利用栈来存储要写入的数据。**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        if not root: 
            return []
        res,stack = [],[root,]
        # stack.append(root)
        while len(stack): #只要栈不为空的时候，就进行迭代
            tmp = stack.pop()
            res.append(tmp.val)
            stack.extend(tmp.children[::-1])
        return res
```

## 树的中序遍历

### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

**题目描述：**![image-20210719115632524](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210719115632524.png)

**解题思路1：递归**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:

        def inorder(root:TreeNode):
            if not root:
                return res
            inorder(root.left)
            res.append(root.val)
            inorder(root.right)
        res = []
        inorder(root)
        return res
```

**解题思路2：迭代**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        if not root:
            return []
        res,stack = [],[]
        while stack or root: # stack为空且root为null时，说明已经遍历结束
            while root: # 可以深入左子树
                stack.append(root)
                root = root.left
            root = stack.pop() # 否则访问栈中节点，并深入右子树
            res.append(root.val)
            root = root.right
        return res


```

### [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

**题目描述：**![image-20210719120016079](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210719120016079.png)

**二叉搜索树的性质：左节点的值<根节点的值<右节点的值**

**解题思路：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def searchBST(self, root: TreeNode, val: int) -> TreeNode:
        def bin_search(root,val):
            if not root:
                return 
            if root.val == val: #1.如果当前节点等于目标节点，那么直接返回
                return root
            elif root.val > val: #2.如果当前节点比目标节点大，那么就在当前节点的左子树进行寻找
                return bin_search(root.left,val)
            else:# 3.否则，在当前节点的右子树进行寻找
                return bin_search(root.right,val)
        return bin_search(root,val)
```

### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

难度：简单

**题目描述：**

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

![image-20210726173651767](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726173651767.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def getMinimumDifference(self, root: TreeNode) -> int:
        def inorder(root):  # 原本是二叉搜索树，中序遍历可以转成有序数组
            if not root:
                return 
            inorder(root.left)
            # if root:
                # res = min(res,)
            order.append(root.val)
            inorder(root.right)
        order = []
        inorder(root)
        r = float('inf')        
        for i in range(len(order)-1):
            r = min(abs(order[i]-order[i+1]),r)
        return r
```

### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

难度：中等

**题目描述：**

![image-20210726175413940](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726175413940.png)![image-20210726175418305](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726175418305.png)![image-20210726175423327](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726175423327.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def convertBST(self, root: TreeNode) -> TreeNode:    
        def inorder(root): # 中序遍历得到有序列表
            nonlocal total #声明这不是局部变量，是一个全局变量
            if root:
                inorder(root.right) #中序遍历，先右再中再左
                total += root.val # 此时已经加上了右边的值，目前加上当前的值
                root.val = total # 将累加值赋给当前节点的值
                inorder(root.left) #最后遍历左子树       
        total = 0
        inorder(root)
        # for i in range(len(order)-1,-1,-1):
        #     order[i] += order[i-1]
        return root


```

### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

难度：中等

**题目描述：**

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

![image-20210726182250945](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726182250945.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        def inorder(root):
            if not root:
                return 
            inorder(root.left)
            res.append(root.val)
            inorder(root.right)
        res = []
        inorder(root)
        return res[k-1]
```

### [173. 二叉搜索树迭代器 ](https://leetcode-cn.com/problems/binary-search-tree-iterator/) ？

难度：中等

**题目描述：**

![image-20210726182704634](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726182704634.png)![image-20210726182710385](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726182710385.png)

**题解：**

提前把 BST 的中序遍历结果保存到一个**队列**里面，当调用 `next()` 方法的时候，就从**队列**头部弹出一个元素。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator: # 一个按中序遍历二叉搜索树的迭代器

    def __init__(self, root: TreeNode):
        self.queue = deque()
        self.inorder(root) 

    def inorder(self,root):
        if not root:
            return 
        self.inorder(root.left)
        self.queue.append(root.val)
        self.inorder(root.right)

    def next(self) -> int:
        return self.queue.popleft()

        return res
    def hasNext(self) -> bool:
        return len(self.queue) > 0


# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
```



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class BSTIterator: # 一个按中序遍历二叉搜索树的迭代器

    def __init__(self, root: TreeNode):
        self.stack = []
        while root: # 初始化为比它小的元素
            self.stack.append(root)
            root = root.left
    def next(self) -> int:
        tmp = self.stack.pop()
        res = tmp.val
        tmp = tmp.right
        while tmp:
            self.stack.append(tmp)
            tmp = tmp.left
        return res
    def hasNext(self) -> bool:
        return self.stack != []




# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
```

### [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

难度：中等

**题目描述：**

给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

![image-20210726185602497](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726185602497.png)

**题解：**

令 `test(node)` 作为该节点上的子树的理想答案。我们可以递归地构建该答案。

算法

当 node.val > R，那么修剪后的二叉树必定出现在节点的左边。

类似地，当 node.val < L，那么修剪后的二叉树出现在节点的右边。否则，我们将会修剪树的两边。



```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def trimBST(self, root: TreeNode, low: int, high: int) -> TreeNode:
        def test(root):
            if not root:
                return None
            if root.val > high:  # 如果中间的节点比最大值还要大，那么右节点肯定就更大了，就开始对左子树进行操作
                return test(root.left)
            if root.val < low: # 如果中间的节点比最小值还要小，那么左节点肯定就更小了，就对右子树进行操作
                return test(root.right)
            else: # 如果root满足了条件，呢么就对左右子树进行相同的修剪
                root.left = test(root.left)
                root.right = test(root.right)
            return root
        return test(root)

```

### [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

难度：中等

**题目描述：**

![image-20210726192414615](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726192414615.png)

![image-20210726192422933](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726192422933.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root: # #第一种情况：没找到删除的节点，遍历到空节点直接返回了
            return root
        if root.val == key:
            if not root.left and not root.right:  #第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
                del root
                return None
            if not root.left and root.right: ##第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
                tmp = root
                root = root.right
                del tmp
                return root
            if not root.right and root.left: # #第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
                tmp = root
                root = root.left
                del tmp 
                return root

            #第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            if root.left and root.right:
                v = root.right
                while v.left:
                    v = v.left
                v.left = root.left
                tmp = root
                root = root.right
                del tmp
                return root
        if root.val > key: # 左递归
            root.left = self.deleteNode(root.left,key)
        if root.val < key: # 右递归
            root.right = self.deleteNode(root.right,key)
        return root

```



### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

难度：简单

**题目描述：**

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

 ![image-20210726190455699](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726190455699.png)

**题解：**

二叉树的每个节点的左右子树的高度差的绝对值不超过 11，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -> bool:

        def depth(root) -> int:
            if not root:
                return 0
            return max(depth(root.left),depth(root.right))+ 1
        if not root:
            return True
        return abs(depth(root.right)-depth(root.left))<= 1 and self.isBalanced(root.left) and self.isBalanced(root.right) 
```

### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

难度：中等

**题目描述：**

给你一个整数 `n` ，请你生成并返回所有由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。

![image-20210726205518586](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726205518586.png)

**题解：**

二叉搜索树关键的性质是根节点的值大于左子树所有节点的值，小于右子树所有节点的值，且左子树和右子树也同样为二叉搜索树。因此在生成所有可行的二叉搜索树的时候，假设当前序列长度为 nn，如果我们枚举根节点的值为 ii，那么根据二叉搜索树的性质我们可以知道左子树的节点值的集合为 [1 \ldots i-1][1…i−1]，右子树的节点值的集合为 [i+1 \ldots n][i+1…n]。而左子树和右子树的生成相较于原问题是一个序列长度缩小的子问题，因此我们可以想到用回溯的方法来解决这道题目。

我们定义 generateTrees(start, end) 函数表示当前值的集合为 [\textit{start},\textit{end}][start,end]，返回序列 [\textit{start},\textit{end}][start,end] 生成的所有可行的二叉搜索树。按照上文的思路，我们考虑枚举 [\textit{start},\textit{end}][start,end] 中的值 ii 为当前二叉搜索树的根，那么序列划分为了 [\textit{start},i-1][start,i−1] 和 [i+1,\textit{end}][i+1,end] 两部分。我们递归调用这两部分，即 generateTrees(start, i - 1) 和 generateTrees(i + 1, end)，获得所有可行的左子树和可行的右子树，那么最后一步我们只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。

递归的入口即为 generateTrees(1, n)，出口为当 \textit{start}>\textit{end}start>end 的时候，当前二叉搜索树为空，返回空节点即可。

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        def generateTrees(start, end):
            if start > end:
                return [None,]
            
            allTrees = []
            for i in range(start, end + 1):  # 枚举可行根节点
                # 获得所有可行的左子树集合
                leftTrees = generateTrees(start, i - 1)
                
                # 获得所有可行的右子树集合
                rightTrees = generateTrees(i + 1, end)
                
                # 从左子树集合中选出一棵左子树，从右子树集合中选出一棵右子树，拼接到根节点上
                for l in leftTrees:
                    for r in rightTrees:
                        currTree = TreeNode(i)
                        currTree.left = l
                        currTree.right = r
                        allTrees.append(currTree)
            
            return allTrees
        
        return generateTrees(1, n) if n else []


```

### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

难度：简单

**题目描述：**

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。

高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

![image-20210726212428986](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726212428986.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        if not nums:
            return None
        else:
            mid = len(nums) // 2
            tn = TreeNode(nums[mid]) # 先把根节点找出来
            
            nums1 = nums[:mid] # 左子树待选的节点
            nums2 = nums[mid+1:] # 右子树待选的节点

            tn.left = self.sortedArrayToBST(nums1) # 根节点的左子树也用这种方法构造
            tn.right = self.sortedArrayToBST(nums2) #同理
        return tn
```

### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

难度：中等

**题目描述：**

给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

![image-20210726212929816](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726212929816.png)

**题解：**

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        inorder = []
        if not head:
            return None
        while head:# 不停把它加到列表中
            inorder.append(head.val)
            head = head.next
        return self.generateTreeByOrder(inorder)
    def generateTreeByOrder(self,inorder):
        if len(inorder) == 0 :
            return 
        midinx = len(inorder) // 2
        rootval = inorder[midinx]
        root = TreeNode(rootval)
    # # [-10, -3, 0, 5, 9]
        root.left = self.generateTreeByOrder(inorder[0:midinx])
        root.right = self.generateTreeByOrder(inorder[midinx+1:])
        return root
```

## 重构二叉树

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

难度：中等

**题目描述：**

给定一棵树的前序遍历 `preorder` 与中序遍历 `inorder`。请构造二叉树并返回其根节点。

 ![image-20210726213735697](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210726213735697.png)

**题解：**

前序遍历的第一个值就是根节点；然后再inorder中找到根节点的位置，这个位置的左边就是左子树，右边就是右子树。



## 树的后序遍历

### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

**题目描述：**

![image-20210719120503267](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210719120503267.png)

**解题思路1：递归**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
       # 递归
        def postorder(root:TreeNode):
            if not root:
                return []
            postorder(root.left)
            postorder(root.right)
            res.append(root.val)
        res = []
        postorder(root)
        return res
```

**解题思路2：迭代**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def postorderTraversal(self, root: TreeNode) -> List[int]:
        # 迭代
        if not root:
            return []
        res,stack = [],[root]
        prev = root # 为了判断父子节点关系
        while len(stack):
            root = stack.pop()# 取出一个节点，表示开始访问以该节点为根的子树
            if (not root.right and not root.left ) or ( root.right ==prev or root.left == prev): 
                # 如果该节点为叶子节点，或者已经访问该节点的子节点
                res.append(root.val) # 直接访问
                prev = root
            else:# 否则就顺序把当前节点，右孩子，左孩子入栈
                stack.append(root)
                if root.right:
                    stack.append(root.right)
                if root.left:
                    stack.append(root.left)
        return res
```

### [590. N 叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)

**题目描述：**

![image-20210719120856526](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210719120856526.png)

**解题思路1：递归**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def postorder(self, root: 'Node') -> List[int]:
        def post_order(t):
            if not t:
                return 
            for i in t.children: # 对于root的每个子孩子都这样操作
                post_order(i)
            res.append(t.val)
        res = []
        post_order(root)
        return res
```

**解题思路2：迭代**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def postorder(self, root: 'Node') -> List[int]:

        if not root:
            return 
        res,stack = [],[root]
        while len(stack):
            node = stack.pop()
            if node :
                res.append(node.val)
            if node.children:
                stack.extend(node.children)
        return res[::-1]
```

## 树的前序序列化

### [606. 根据二叉树创建字符串](https://leetcode-cn.com/problems/construct-string-from-binary-tree/)

**题目描述：**

![image-20210719121333414](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210719121333414.png)

**解题思路1：递归**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def tree2str(self, root: TreeNode) -> str:
        # 递归
        def preorder(root):
            if not root:
                return ''
            if not root.left and root.right: #1.如果没有左节点，只有右节点，那么直接（根节点（）（右子树））
                return str(root.val) + '()' + '('+preorder(root.right)+')'
            if root.left and not root.right:#2.如果没有右节点，只有左节点，那么直接（根节点（左子树））
                return str(root.val) + '(' + preorder(root.left) + ')'
            if not root.left and not root.right:#3.如果只有根节点，那么直接返回
                return str(root.val)
            #4.如果上述都不满足，即既有左也有右，那么：
            return str(root.val) + '(' + preorder(root.left) + ')' + '(' + preorder(root.right)+')'
        return preorder(root)
```

**解题思路2：迭代**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def tree2str(self, root: TreeNode) -> str:
 # # 迭代，模拟递归
         # 当确定有儿子时再加右括号
        # # 当再次便来到此结点时，表示该子树遍历结束，加右括号
        if not root:
            return ''
        ans = ''
        stack = [root]
        reached = set()
        while stack:
            node = stack[-1]
            if node in reached: # 退栈，并加右括号
                stack.pop()
                ans += ')'
            else: # 此节点没有遍历过，添加左括号和数值
                ans += '(' + str(node.val)
                reached.add(node)
                if not node.left and node.right:
                    ans += '()'
                if node.right:
                    stack.append(node.right)
                if node.left:
                    stack.append(node.left)

        return ans[1:len(ans)-1]
```

### [331. 验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

**题目描述：**

![image-20210719123703306](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210719123703306.png)

序列化二叉树就是对一个二叉树进行前序遍历，遇见空节点就添加一个标记值（如#），这样就会得到一个字符串。

**解题思路：迭代**

```python
class Solution:
    def isValidSerialization(self, preorder: str) -> bool:
        stack = []
        for node in preorder.split(','): #1.先将字符串拆成列表形式
            stack.append(node) #2.把每个node加到列表里
            #3.叶子节点一定是x，#，#这样的形式，所以如果一个列表中最后三个是这样的形式：[3，#，#],那么一定是叶子节点，就删除他们三个，再添加一个叶子节点#即可
            while len(stack) >= 3 and stack[-1] == stack[-2] == '#' and stack[-3] != '#':
                stack.pop(),stack.pop(),stack.pop()
                stack.append('#')
        return len(stack) == 1 and stack.pop() =='#' # 当最后一个是#时为true，表示这个字符串是正确的序列化二叉树
```

### [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

**题目描述：**

![image-20210719124159207](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210719124159207.png)

**解题思路：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

# 可以考虑用字典进行记录，每一个子树都是只有三个节点值组成：根，左，右。只要这三个节点值都相等，就认为是一组重复的子树。所以我们要建立一个这样的字典，这个字典的键值key是根左右节点的值，value值是其出现的次数。
class Solution:
    def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
        count = collections.Counter()
        ans = []
        def coll(node):
            if not node:
                return '#'
            # 1.建立一个key，它是由根，左，右的值组成的
            serial = "{},{},{}".format(node.val,coll(node.left),coll(node.right))
            count[serial] = count.get(serial,0) + 1   #2.统计这个key出现的次数
            if count[serial] ==2:
                ans.append(node) #3.如果出现次数大于2，说明它是重复子树的根节点，要加到列表中去
            return serial #4.这个key还要参与下一次的计算
        coll(root)
        return ans
```

### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

难度：困难

**题目描述：**

![image-20210727190025564](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727190025564.png)![image-20210727190029888](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727190029888.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        # DFS
        # 选择前序遍历，是因为 根|左|右根∣左∣右 的打印顺序，在反序列化时更容易定位出根节点的值。遇到 null 节点也要翻译成特定符号，反序列化时才知道这里是 null。
        if not root:
            return 'X,'
        leftserialize = self.serialize(root.left)
        rightserialize = self.serialize(root.right)
        return str(root.val)+','+leftserialize+rightserialize      
# 定义函数 buildTree 用于还原二叉树，传入由序列化字符串转成的 list 数组。逐个 pop 出 list 的首项，构建当前子树的根节点，顺着 list，构建顺序是根节点，左子树、右子树。如果弹出的字符为 "X"，则返回 null 节点。如果弹出的字符是数值，则创建root节点，并递归构建root的左右子树，最后返回root。
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        data = data.split(',')
        root = self.bulidTrees(data)
        return root

    def bulidTrees(self,data):
        val = data.pop(0)
        if val == 'X':
            return None
        node = TreeNode(val)
        node.left = self.bulidTrees(data)
        node.right = self.bulidTrees(data)
        return node
        

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
```

BFS 解法
序列化——很典型的 BFS
维护一个队列，初始让根节点入列，考察出列节点：
如果出列的节点是 null，将符号 'X' 推入 res 数组。
如果出列的节点是数值，将节点值推入数组 res，并将它的左右子节点入列。
子节点 null 也要入列，它对应 "X"，要被记录，只是它没有子节点可入列。
入列、出列…直到队列为空，就遍历完所有节点，res构建完毕，转成字符串就好。

反序列化——也是BFS

下图是BFS得到的序列化字符串，和DFS得到的不同，它是一层层的。除了第一个是根节点的值，其他节点值都是成对的，对应左右子节点。![image-20210727192225086](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727192225086.png)

依然先转成list数组，用一个指针 cursor 从第二项开始扫描。
起初，用list[0]构建根节点，并让根节点入列。
节点出列，此时 cursor 指向它的左子节点值，cursor+1 指向它的右子节点值。
如果子节点值是数值，则创建节点，并认出列的父亲，同时自己也是父亲，入列。
如果子节点值为 'X'，什么都不用做，因为出列的父亲的 left 和 right 本来就是 null
可见，所有的真实节点都会在队列里走一遍，出列就带出儿子入列

![image-20210727192245693](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727192245693.png)

```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        # BFS
        if not root:
            return []
        queue = deque([root])
        res = ''
        while queue:
            curnode = queue.popleft()
            if curnode:
                res += str(curnode.val)+','
                queue.append(curnode.left)
                queue.append(curnode.right)
            else:
                res += 'X,'
        return res
        
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        if not data:
            return None
        data = data.split(',')
        root = TreeNode(data.pop(0))
        queue = [root]
        while queue:
            curnode = queue.pop(0)
            if data:
                val = data.pop(0)
                if val != 'X':
                    curnode.left = TreeNode(val)
                    queue.append(curnode.left)
            if data:
                val = data.pop(0)
                if val != 'X':
                    curnode.right = TreeNode(val)
                    queue.append(curnode.right)
        return root


# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
```

### [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)

难度：中等

**题目描述：**

![image-20210727193618580](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727193618580.png)![image-20210727193622308](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727193622308.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root: TreeNode) -> str:
        """Encodes a tree to a single string.
        """
        def preorder(root):
            out = []
            if root:
                out += [str(root.val)]
                out += preorder(root.left)
                out += preorder(root.right)
            return out
        return ','.join(preorder(root))
        

    def deserialize(self, data: str) -> TreeNode:
        """Decodes your encoded data to tree.
        """
        if not data :
            return None
        def buildTree(pre_o,in_o):
            if not pre_o:
                return None
            mid = pre_o[0]
            i = in_o.index(mid)
            root = TreeNode(mid)
            root.left = buildTree(pre_o[1:i+1],in_o[:i])
            root.right = buildTree(pre_o[i+1:],in_o[i+1:])
            return root
        pre_o = list(map(int,data.split(',')))
        in_o = sorted(pre_o)
        return buildTree(pre_o,in_o)

# Your Codec object will be instantiated and called as such:
# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# tree = ser.serialize(root)
# ans = deser.deserialize(tree)
# return ans
```

## 二叉树的展开

### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

难度：中等

**题目描述：**

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。

![image-20210727200150535](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727200150535.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -> None:
        """
        Do not return anything, modify root in-place instead.
        """
        stack = [root]
        if not root:
            return None
        while stack:
            curnode = stack.pop()
            if curnode.right:
                stack.append(curnode.right)
            if curnode.left:
                stack.append(curnode.left)
            if stack != []:
                curnode.left = None
                curnode.right = stack[-1]
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def flatten(self, root: TreeNode) -> None:
        preoderlist = []
        def preoder(root:TreeNode):
            if not root:
                return []
            preoderlist.append(root)
            preoder(root.left)
            preoder(root.right)
        preoder(root)
        for i in range(1,len(preoderlist)):
            prev , curr = preoderlist[i-1],preoderlist[i]
            prev.left = None
            prev.right = curr
 #将二叉树展开为单链表之后，单链表中的节点顺序即为二叉树的前序遍历访问各节点的顺序。因此，可以对二叉树进行前序遍历，获得各节点被访问到的顺序。由于将二叉树展开为链表之后会破坏二叉树的结构，因此在前序遍历结束之后更新每个节点的左右子节点的信息，将二叉树展开为单链表。
```

## 最近公共祖先

### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

难度：简单

**题目描述：**

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。![image-20210727205228979](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727205228979.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if p.val < root.val and q.val < root.val:#直到找到一个点，让pq分布两侧
            return self.lowestCommonAncestor(root.left,p,q)
        elif p.val>root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right,p,q)
        return root


```

### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

难度：中等

**题目描述：**

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

![image-20210727205631571](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727205631571.png)

**题解：**

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root==q:
            return root
        left = self.lowestCommonAncestor(root.left,p,q) # 左子树和右子树都去找，如果有一个不存在，那么久返回另一个
        right = self.lowestCommonAncestor(root.right,p,q)
        #如果两个都存在，说明在两边都可以找到值，那么久返回他们的父节点
        if not left:
            return right
        if not right:
            return left
        return root 
```

## Morris中序遍历

### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

难度：简单

**题目描述**

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值

- 结点右子树中所含结点的值大于等于当前结点的值

- 左子树和右子树都是二叉搜索树![image-20210727210141857](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727210141857.png)

  **题解：**

  主要思想是中序遍历这个树，然后每到一个节点，都记录下它是否等于上一个节点base，如果等于，那么count+1，否则单开一个计数count=1，之后，如果count总的数量=maxcount，那么就将其加到ans中，如果大于maxcount，那么maxcount更新。

  ```python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def findMode(self, root: TreeNode) -> List[int]:
          def midorder(node):
              if not node:
                  return
              midorder(node.left)
              update(node.val)
              midorder(node.right)
          ans = [] # 存数量最大的节点
          base = None# 当前节点
          count = 0
          maxcount = 0
          def update(x):
              nonlocal base,count,maxcount,ans
              if x == base:
                  count += 1
              else: 
                  base = x
                  count = 1
              if count == maxcount:
                  ans.append(x)
              elif count > maxcount:
                  maxcount = count
                  ans.clear()
                  ans.append(x)
          midorder(root)
          return ans
  ```

  ### [99. 恢复二叉搜索树](https://leetcode-cn.com/problems/recover-binary-search-tree/)

  难度：中等

  **题目描述：**

  给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。

  进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？

  ![image-20210727211102998](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727211102998.png)

  **题解：**

  ```python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def recoverTree(self, root: TreeNode) -> None:
          """
          Do not return anything, modify root in-place instead.
          """
          def midorder(node):
              if not node:
                  return 
              midorder(node.left)
              res.append(node)
              midorder(node.right)
              return res
          res = []
          midorder(root)
          new = sorted([_.val for _ in res]) # 正确的中序二叉树
          change = []
          # 比较这两个列表得到交换的两个节点（值不对应的两个节点）
          for i in range(len(new)):
              if res[i].val != new[i]:
                  change.append(res[i])
          # 重置两个节点的值
          change[0].val,change[1].val= change[1].val,change[0].val
          return root
  
  ```

  ```python
  # Definition for a binary tree node.
  # class TreeNode:
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution:
      def recoverTree(self, root: TreeNode) -> None:
          """
          Do not return anything, modify root in-place instead.
          """
          def midorder(root):
              if not root:
                  return
              midorder(root.left)
              if pre[0] and root and pre[0].val > root.val:# 说明出错了
                  if len(change) == 0:
                      change.append(pre[0])
                      change.append(root)
                  else:
                      change[1] = root #change节点不相邻的情况
              if root:
                  pre[0] = root
              midorder(root.right)
          change = []
          pre = [None]
          midorder(root)
          change[0].val,change[1].val = change[1].val,change[0].val
  ```

  ## 四叉树

  ### [558. 四叉树交集](https://leetcode-cn.com/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/) ?

  难度：中等

  **题目描述：**

  ![image-20210727214106590](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727214106590.png)![image-20210727214114803](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727214114803.png)

![image-20210727214141490](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20210727214141490.png)

**题解：**

```python
"""
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
"""

class Solution:
    def intersect(self, quadTree1: 'Node', quadTree2: 'Node') -> 'Node':
        # 如果A为叶子节点，并且A的值等于true，这时直接返回true，不用管B
        # 如果A为叶子节点，但是A的值等于false，这时直接返回B就可以了（注意，即使B不是一个叶子节点，也要直接返回）
        # 如果A不为叶子节点，原理一样，这时看B，如果B为叶子节点，并且B 的值为true，则直接返回true，不用管A
        # 如果A不为叶子节点，B为叶子节点，并且B的值为false，这时直接返回A
        # 如果A和B都不为叶子节点，这时分别再将A,B的四个子节点传入下一次递归计算结果
        # 最后 如果A和B的四个子节点的值都为ture的话，这时需要进行合并为一个节点
        if (quadTree1.isLeaf and quadTree1.val) or (quadTree2.isLeaf and not quadTree2.val):
            return quadTree1
        elif (quadTree2.isLeaf and quadTree2.val) or (quadTree1.isLeaf and not quadTree1.val):
            return quadTree2
        else:
            l1 = self.intersect(quadTree1.topLeft,quadTree2.topLeft)
            l2 = self.intersect(quadTree1.topRight,quadTree2.topRight)
            l3 = self.intersect(quadTree1.bottomLeft,quadTree2.bottomLeft)
            l4 = self.intersect(quadTree1.bottomRight,quadTree2.bottomRight)
            if l1.isLeaf and l2.isLeaf and l3.isLeaf and l4.isLeaf and l1.val == l2.val == l3.val == l4.val:
                return l1
            return Node(None,False,l1,l2,l3,l4)
```

### [427. 建立四叉树](https://leetcode-cn.com/problems/construct-quad-tree/)

难度：中等

**题目描述：**

给你一个 `n * n` 矩阵 `grid` ，矩阵由若干 `0` 和 `1` 组成。请你用四叉树表示该矩阵 `grid` 。

你需要返回能表示矩阵的 四叉树 的根结点。

**题解：**

意思就是说： 如果传入的这个矩阵所有值都一样（0或1），那么这个节点就是叶子节点，直接返回
Node(节点的值,True,None,None,None,None)就可以了； 否则我们就把这个矩阵分成四块小矩阵s b c d，再去对每个小矩阵做上述事情（递归开始）； 最后我们返回
Node(True,False,self.construct(a),self.construct(b),self.construct(c),self.construct(d))就可以了

```python
"""
# Definition for a QuadTree node.
class Node:
    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
        self.val = val
        self.isLeaf = isLeaf
        self.topLeft = topLeft
        self.topRight = topRight
        self.bottomLeft = bottomLeft
        self.bottomRight = bottomRight
"""

class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        # 大概意思是说传入的矩阵如果全是一样的值，那么isleaf就是true，也就是叶子节点
        if not grid:
            return
        nums = set(sum(grid,[]))
        if len(nums) == 1: # 去重后发现是一样的，那么就是叶子节点
            return Node(nums.pop(),True,None,None,None,None)
        # partition into four blocks
        n = len(grid) # 否则就需要分为四块
        grid1 = [grid[i][:n//2] for i in range(n//2)]
        grid2 = [grid[i][n//2:] for i in range(n//2)]
        grid3 = [grid[i][:n//2] for i in range(n//2,n)]
        grid4 = [grid[i][n//2:] for i in range(n//2,n)]
        return Node(True,False,self.construct(grid1),self.construct(grid2),self.construct(grid3),self.construct(grid4))

```

